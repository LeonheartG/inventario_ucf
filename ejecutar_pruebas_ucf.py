#!/usr/bin/env python3
"""
Script para ejecutar todas las pruebas del Sistema UCF
Basado en las especificaciones del documento de Yaidel√≠n Chaviano

Estrategia de pruebas implementada:
- Pruebas unitarias (m√≥dulo inventario)
- Pruebas de integraci√≥n (m√≥dulo usuarios)
- Pruebas de aceptaci√≥n (m√≥dulo diagn√≥stico)

Uso:
    python ejecutar_pruebas_ucf.py [opciones]
"""

import os
import sys
import django
from django.conf import settings
from django.test.utils import get_runner
from django.core.management import execute_from_command_line
import time
import subprocess
from io import StringIO
from contextlib import redirect_stdout, redirect_stderr


class TestRunner:
    """
    Ejecutor de pruebas del Sistema UCF
    Implementa la estrategia de pruebas del documento de Yaidel√≠n Chaviano
    """

    def __init__(self):
        self.setup_project_paths()
        self.setup_django()
        self.resultados = {
            'unitarias': {'total': 0, 'exitosas': 0, 'fallidas': 0, 'tiempo': 0},
            'integracion': {'total': 0, 'exitosas': 0, 'fallidas': 0, 'tiempo': 0},
            'aceptacion': {'total': 0, 'exitosas': 0, 'fallidas': 0, 'tiempo': 0}
        }

    def setup_project_paths(self):
        """Configurar paths del proyecto para ejecuci√≥n sin entorno virtual"""
        # Obtener directorio actual (ra√≠z del proyecto)
        project_root = os.path.dirname(os.path.abspath(__file__))

        # Agregar ra√≠z del proyecto al Python path si no est√°
        if project_root not in sys.path:
            sys.path.insert(0, project_root)

        # Cambiar al directorio del proyecto
        os.chdir(project_root)

        print(f"üìÅ Directorio de trabajo: {project_root}")

    def setup_django(self):
        """Configurar entorno Django para las pruebas"""
        try:
            os.environ.setdefault('DJANGO_SETTINGS_MODULE',
                                  'inventario_ucf.settings')
            django.setup()
        except Exception as e:
            print(f"‚ùå Error configurando Django: {e}")
            print(
                "   Verifica que el archivo settings.py est√© en inventario_ucf/settings.py")
            sys.exit(1)

    def print_header(self, titulo):
        """Imprimir encabezado de secci√≥n"""
        print("\n" + "="*80)
        print(f"   {titulo}")
        print("="*80)

    def print_subheader(self, subtitulo):
        """Imprimir subencabezado"""
        print(f"\n{'-'*60}")
        print(f"   {subtitulo}")
        print(f"{'-'*60}")

    def verificar_dependencias(self):
        """Verificar dependencias necesarias para las pruebas - Mejorado para sin entorno virtual"""
        self.print_subheader("VERIFICACI√ìN DE DEPENDENCIAS")

        dependencias = [
            ('Django', 'django'),
            ('Pillow', 'PIL'),
            ('ReportLab', 'reportlab'),
            ('XlsxWriter', 'xlsxwriter'),
        ]

        dependencias_faltantes = []
        dependencias_instaladas = []

        for nombre, modulo in dependencias:
            try:
                # Intentar importar el m√≥dulo
                imported_module = __import__(modulo)

                # Verificar si realmente se import√≥ correctamente
                if hasattr(imported_module, '__version__'):
                    version = imported_module.__version__
                elif hasattr(imported_module, 'VERSION'):
                    version = str(imported_module.VERSION)
                elif hasattr(imported_module, 'version'):
                    version = str(imported_module.version)
                else:
                    version = "instalado"

                print(f"‚úÖ {nombre} - Instalado ({version})")
                dependencias_instaladas.append(nombre)

            except ImportError as e:
                print(f"‚ùå {nombre} - NO INSTALADO")
                print(f"   Error: {str(e)}")
                dependencias_faltantes.append(nombre)
            except Exception as e:
                print(f"‚ö†Ô∏è  {nombre} - ERROR AL VERIFICAR: {str(e)}")
                dependencias_faltantes.append(nombre)

        print(f"\nüìä Resumen de dependencias:")
        print(f"   ‚úÖ Instaladas: {len(dependencias_instaladas)}")
        print(f"   ‚ùå Faltantes: {len(dependencias_faltantes)}")

        if dependencias_faltantes:
            print(
                f"\n‚ö†Ô∏è  Dependencias faltantes: {', '.join(dependencias_faltantes)}")
            print("   Para instalar manualmente:")
            for dep in dependencias_faltantes:
                if dep == 'Pillow':
                    print("     pip install Pillow")
                elif dep == 'ReportLab':
                    print("     pip install reportlab")
                elif dep == 'XlsxWriter':
                    print("     pip install XlsxWriter")
                else:
                    print(f"     pip install {dep}")
            print("\n   O instalar todas desde requirements.txt:")
            print("     pip install -r requirements.txt")

            # Intentar autoinstalaci√≥n
            respuesta = input(
                "\n¬øDeseas intentar instalar autom√°ticamente las dependencias faltantes? (s/n): ")
            if respuesta.lower() in ['s', 'si', 's√≠', 'y', 'yes']:
                self.autoinstalar_dependencias(dependencias_faltantes)
                return self.verificar_dependencias()  # Re-verificar despu√©s de la instalaci√≥n
            else:
                return False
        else:
            print("\n‚úÖ Todas las dependencias est√°n instaladas")
            return True

    def autoinstalar_dependencias(self, dependencias_faltantes):
        """Intentar instalar autom√°ticamente las dependencias faltantes"""
        print("\nüîß Intentando instalar dependencias autom√°ticamente...")

        # Mapeo de nombres de dependencias a nombres de paquetes pip
        pip_names = {
            'Pillow': 'Pillow',
            'ReportLab': 'reportlab',
            'XlsxWriter': 'XlsxWriter',
            'Django': 'Django'
        }

        for dep in dependencias_faltantes:
            if dep in pip_names:
                package_name = pip_names[dep]
                try:
                    print(f"   Instalando {package_name}...")
                    subprocess.check_call(
                        [sys.executable, '-m', 'pip', 'install', package_name])
                    print(f"   ‚úÖ {dep} instalado correctamente")
                except subprocess.CalledProcessError as e:
                    print(f"   ‚ùå Error instalando {dep}: {e}")
                except Exception as e:
                    print(f"   ‚ùå Error inesperado instalando {dep}: {e}")

    def ejecutar_pruebas_unitarias(self):
        """
        Ejecutar pruebas unitarias del m√≥dulo inventario
        Secci√≥n 3.2.1: Pruebas unitarias para componentes individuales
        """
        self.print_subheader("PRUEBAS UNITARIAS - M√ìDULO INVENTARIO")
        print("Validando l√≥gica de negocio en componentes individuales...")

        start_time = time.time()

        try:
            # Configurar runner de pruebas
            TestRunner = get_runner(settings)
            test_runner = TestRunner(
                verbosity=2, interactive=False, keepdb=True)

            # Ejecutar pruebas unitarias del inventario
            failures = test_runner.run_tests(['inventario.test_unitarias'])

            end_time = time.time()
            self.resultados['unitarias']['tiempo'] = round(
                end_time - start_time, 2)

            if failures == 0:
                print("‚úÖ TODAS LAS PRUEBAS UNITARIAS PASARON")
                self.resultados['unitarias']['exitosas'] = 1
            else:
                print(f"‚ùå {failures} PRUEBAS UNITARIAS FALLARON")
                self.resultados['unitarias']['fallidas'] = failures

        except Exception as e:
            print(f"‚ùå ERROR EJECUTANDO PRUEBAS UNITARIAS: {str(e)}")
            self.resultados['unitarias']['fallidas'] = 1

        print(
            f"‚è±Ô∏è  Tiempo de ejecuci√≥n: {self.resultados['unitarias']['tiempo']} segundos")

    def ejecutar_pruebas_integracion(self):
        """
        Ejecutar pruebas de integraci√≥n del m√≥dulo usuarios
        Secci√≥n 3.2.2: Pruebas de interacci√≥n entre componentes
        """
        self.print_subheader("PRUEBAS DE INTEGRACI√ìN - M√ìDULO USUARIOS")
        print("Validando interacci√≥n entre componentes del sistema...")

        start_time = time.time()

        try:
            TestRunner = get_runner(settings)
            test_runner = TestRunner(
                verbosity=2, interactive=False, keepdb=True)

            # Ejecutar pruebas de integraci√≥n
            failures = test_runner.run_tests(['usuarios.test_integracion'])

            end_time = time.time()
            self.resultados['integracion']['tiempo'] = round(
                end_time - start_time, 2)

            if failures == 0:
                print("‚úÖ TODAS LAS PRUEBAS DE INTEGRACI√ìN PASARON")
                self.resultados['integracion']['exitosas'] = 1
            else:
                print(f"‚ùå {failures} PRUEBAS DE INTEGRACI√ìN FALLARON")
                self.resultados['integracion']['fallidas'] = failures

        except Exception as e:
            print(f"‚ùå ERROR EJECUTANDO PRUEBAS DE INTEGRACI√ìN: {str(e)}")
            self.resultados['integracion']['fallidas'] = 1

        print(
            f"‚è±Ô∏è  Tiempo de ejecuci√≥n: {self.resultados['integracion']['tiempo']} segundos")

    def ejecutar_pruebas_aceptacion(self):
        """
        Ejecutar pruebas de aceptaci√≥n del m√≥dulo diagn√≥stico
        Secci√≥n 3.2.3: Pruebas de usabilidad y satisfacci√≥n de requisitos
        """
        self.print_subheader("PRUEBAS DE ACEPTACI√ìN - M√ìDULO DIAGN√ìSTICO")
        print("Validando usabilidad y satisfacci√≥n de requisitos...")

        start_time = time.time()

        try:
            TestRunner = get_runner(settings)
            test_runner = TestRunner(
                verbosity=2, interactive=False, keepdb=True)

            # Ejecutar pruebas de aceptaci√≥n
            failures = test_runner.run_tests(['diagnostico.test_aceptacion'])

            end_time = time.time()
            self.resultados['aceptacion']['tiempo'] = round(
                end_time - start_time, 2)

            if failures == 0:
                print("‚úÖ TODAS LAS PRUEBAS DE ACEPTACI√ìN PASARON")
                self.resultados['aceptacion']['exitosas'] = 1
            else:
                print(f"‚ùå {failures} PRUEBAS DE ACEPTACI√ìN FALLARON")
                self.resultados['aceptacion']['fallidas'] = failures

        except Exception as e:
            print(f"‚ùå ERROR EJECUTANDO PRUEBAS DE ACEPTACI√ìN: {str(e)}")
            self.resultados['aceptacion']['fallidas'] = 1

        print(
            f"‚è±Ô∏è  Tiempo de ejecuci√≥n: {self.resultados['aceptacion']['tiempo']} segundos")

    def verificar_cobertura_codigo(self):
        """
        Verificar cobertura de c√≥digo (si coverage est√° instalado)
        Objetivo: >80% seg√∫n buenas pr√°cticas
        """
        self.print_subheader("AN√ÅLISIS DE COBERTURA DE C√ìDIGO")

        try:
            # Verificar si coverage est√° instalado
            subprocess.run([sys.executable, '-m', 'coverage', '--version'],
                           capture_output=True, check=True)

            print("üìä Generando reporte de cobertura...")

            # Ejecutar pruebas con coverage
            subprocess.run([
                sys.executable, '-m', 'coverage', 'run', '--source=.',
                'manage.py', 'test',
                'inventario.test_unitarias',
                'usuarios.test_integracion',
                'diagnostico.test_aceptacion'
            ], check=True)

            # Generar reporte
            result = subprocess.run([sys.executable, '-m', 'coverage', 'report'],
                                    capture_output=True, text=True)

            print("üìà Reporte de Cobertura:")
            print(result.stdout)

            # Generar reporte HTML
            subprocess.run(
                [sys.executable, '-m', 'coverage', 'html'], check=True)
            print("üìä Reporte HTML generado en htmlcov/index.html")

        except subprocess.CalledProcessError:
            print("‚ö†Ô∏è  Coverage no est√° instalado o fall√≥")
            print("   Instalar con: pip install coverage")
        except FileNotFoundError:
            print("‚ö†Ô∏è  Coverage no encontrado")

    def generar_reporte_resultados(self):
        """Generar reporte final de resultados"""
        self.print_header("REPORTE FINAL DE PRUEBAS")

        # Calcular totales
        total_exitosas = sum(r['exitosas'] for r in self.resultados.values())
        total_fallidas = sum(r['fallidas'] for r in self.resultados.values())
        tiempo_total = sum(r['tiempo'] for r in self.resultados.values())

        print(f"""
üìã RESUMEN EJECUTIVO:
   ‚Ä¢ Pruebas exitosas: {total_exitosas}/3 m√≥dulos
   ‚Ä¢ Pruebas fallidas:  {total_fallidas}
   ‚Ä¢ Tiempo total:      {tiempo_total:.2f} segundos

üìä DETALLE POR TIPO DE PRUEBA:
""")

        tipos_prueba = {
            'unitarias': 'Pruebas Unitarias (Inventario)',
            'integracion': 'Pruebas de Integraci√≥n (Usuarios)',
            'aceptacion': 'Pruebas de Aceptaci√≥n (Diagn√≥stico)'
        }

        for tipo, nombre in tipos_prueba.items():
            resultado = self.resultados[tipo]
            estado = "‚úÖ √âXITO" if resultado['exitosas'] > 0 else "‚ùå FALL√ì"
            print(f"   ‚Ä¢ {nombre}: {estado} ({resultado['tiempo']:.2f}s)")

        # Indicadores de calidad seg√∫n el documento
        print(f"""
üéØ INDICADORES DE CALIDAD:
   ‚Ä¢ Reducci√≥n de errores: {"‚úÖ Logrado" if total_fallidas == 0 else "‚ùå Pendiente"}
   ‚Ä¢ Tiempo de respuesta:  {"‚úÖ <3s por m√≥dulo" if all(r['tiempo'] < 3 for r in self.resultados.values()) else "‚ö†Ô∏è  Revisar"}
   ‚Ä¢ Cobertura de c√≥digo:  {"üìä Ver reporte coverage" if self.verificar_coverage_disponible() else "‚ö†Ô∏è  No medido"}

üèÜ NIVEL DE CALIDAD ALCANZADO:
""")

        if total_fallidas == 0:
            print("   ü•á EXCELENTE - Todas las pruebas pasaron")
            print("   ‚úÖ Sistema listo para producci√≥n")
        elif total_fallidas <= 2:
            print("   ü•à BUENO - Algunas pruebas requieren atenci√≥n")
            print("   ‚ö†Ô∏è  Revisar fallos antes de despliegue")
        else:
            print("   ü•â MEJORABLE - M√∫ltiples fallos detectados")
            print("   ‚ùå Requiere correcciones antes de continuar")

    def verificar_coverage_disponible(self):
        """Verificar si coverage est√° disponible"""
        try:
            subprocess.run([sys.executable, '-m', 'coverage', '--version'],
                           capture_output=True, check=True)
            return True
        except:
            return False

    def ejecutar_suite_completa(self):
        """Ejecutar suite completa de pruebas"""
        self.print_header("SISTEMA DE PRUEBAS UCF - YAIDEL√çN CHAVIANO")
        print("Implementando estrategia de pruebas del documento de investigaci√≥n")
        print("Universidad de Cienfuegos - Sistema de Gesti√≥n de Inventarios Tecnol√≥gicos")

        # Verificar dependencias
        if not self.verificar_dependencias():
            print("\n‚ùå No se pueden ejecutar las pruebas sin las dependencias")
            return

        # Ejecutar cada tipo de prueba
        self.ejecutar_pruebas_unitarias()
        self.ejecutar_pruebas_integracion()
        self.ejecutar_pruebas_aceptacion()

        # Verificar cobertura si est√° disponible
        self.verificar_cobertura_codigo()

        # Generar reporte final
        self.generar_reporte_resultados()

    def ejecutar_por_tipo(self, tipo_prueba):
        """Ejecutar solo un tipo espec√≠fico de pruebas"""
        if tipo_prueba == 'unitarias':
            self.ejecutar_pruebas_unitarias()
        elif tipo_prueba == 'integracion':
            self.ejecutar_pruebas_integracion()
        elif tipo_prueba == 'aceptacion':
            self.ejecutar_pruebas_aceptacion()
        else:
            print(f"‚ùå Tipo de prueba no v√°lido: {tipo_prueba}")
            print("   Tipos v√°lidos: unitarias, integracion, aceptacion")


def main():
    """Funci√≥n principal del script"""
    import argparse

    parser = argparse.ArgumentParser(
        description='Ejecutor de pruebas del Sistema UCF',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Ejemplos de uso:
  python ejecutar_pruebas_ucf.py                    # Ejecutar todas las pruebas
  python ejecutar_pruebas_ucf.py --tipo unitarias   # Solo pruebas unitarias
  python ejecutar_pruebas_ucf.py --tipo integracion # Solo pruebas de integraci√≥n
  python ejecutar_pruebas_ucf.py --tipo aceptacion  # Solo pruebas de aceptaci√≥n
  python ejecutar_pruebas_ucf.py --coverage         # Incluir an√°lisis de cobertura
        """
    )

    parser.add_argument(
        '--tipo',
        choices=['unitarias', 'integracion', 'aceptacion'],
        help='Tipo espec√≠fico de pruebas a ejecutar'
    )

    parser.add_argument(
        '--coverage',
        action='store_true',
        help='Incluir an√°lisis de cobertura de c√≥digo'
    )

    parser.add_argument(
        '--verbose',
        action='store_true',
        help='Salida detallada'
    )

    args = parser.parse_args()

    # Crear runner
    runner = TestRunner()

    try:
        if args.tipo:
            # Ejecutar tipo espec√≠fico
            runner.ejecutar_por_tipo(args.tipo)
        else:
            # Ejecutar suite completa
            runner.ejecutar_suite_completa()

    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è  Ejecuci√≥n interrumpida por el usuario")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Error inesperado: {str(e)}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
